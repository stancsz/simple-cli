import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { execFile } from "child_process";
import { promisify } from "util";
import fetch from "node-fetch";

const execFileAsync = promisify(execFile);

export function registerApplySecurityPatchTool(server: McpServer) {
    server.tool(
        "apply_security_patch",
        "Applies a security patch for critical/high CVEs by creating a branch, updating the package, and opening a PR.",
        {
            package_name: z.string().describe("Name of the npm package to patch."),
            version: z.string().describe("Target version to patch to."),
            cve_id: z.string().describe("The CVE ID associated with the vulnerability."),
            severity: z.enum(["critical", "high"]).describe("Severity of the vulnerability.")
        },
        async ({ package_name, version, cve_id, severity }) => {
            try {
                if (severity !== "critical" && severity !== "high") {
                    return {
                        content: [{ type: "text", text: "Patching is only automated for critical and high severity vulnerabilities." }],
                        isError: true
                    };
                }

                const branchName = `security-patch-${package_name}-${version.replace(/\./g, "-")}`;
                const commitMessage = `SECURITY: Patch ${package_name} to v${version} for ${cve_id}`;

                // Git operations
                try {
                    await execFileAsync('git', ['checkout', '-b', branchName]);
                } catch (e: any) {
                    // Branch might exist, try to update it
                     if (!e.message.includes("already exists")) {
                         throw e;
                     }
                     await execFileAsync('git', ['checkout', branchName]);
                }

                await execFileAsync('npm', ['install', `${package_name}@${version}`]);
                await execFileAsync('git', ['add', 'package.json', 'package-lock.json']);
                await execFileAsync('git', ['commit', '-m', commitMessage]);

                // Push to remote (assuming origin is configured correctly)
                try {
                    await execFileAsync('git', ['push', '-u', 'origin', branchName]);
                } catch (e: any) {
                    console.warn(`Failed to push branch to remote: ${e.message}`);
                }

                // Create PR via GitHub API
                const githubToken = process.env.GITHUB_TOKEN;
                if (!githubToken) {
                     return {
                         content: [{ type: "text", text: `Branch '${branchName}' created and committed, but GITHUB_TOKEN not found. PR must be created manually.` }]
                     };
                }

                // Try to infer owner/repo from git origin
                const remoteResult = await execFileAsync('git', ['config', '--get', 'remote.origin.url']);
                const remoteUrl = remoteResult.stdout.trim();
                let owner = "";
                let repo = "";

                // Basic parsing for github.com URLs (ssh or https)
                const match = remoteUrl.match(/github\.com[:/]([^/]+)\/([^.]+)/);
                if (match) {
                    owner = match[1];
                    repo = match[2];
                }

                if (!owner || !repo) {
                     return {
                         content: [{ type: "text", text: `Could not parse GitHub owner/repo from origin URL '${remoteUrl}'. PR must be created manually.` }]
                     };
                }

                const prTitle = commitMessage;
                const prBody = `Automated security patch for **${package_name}** to mitigate **${cve_id}** (${severity} severity).\n\nAutomatically generated by Security Monitor MCP.`;

                // Get default branch (assuming main, could be master)
                const defaultBranch = "main";

                // Actual HTTP call
                const prResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/pulls`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `token ${githubToken}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: prTitle,
                        body: prBody,
                        head: branchName,
                        base: defaultBranch
                    })
                });

                if (!prResponse.ok) {
                    const errorData = await prResponse.json();
                     return {
                         content: [{ type: "text", text: `Branch committed, but failed to create PR via API: ${JSON.stringify(errorData)}` }]
                     };
                }

                const prData = await prResponse.json();

                return {
                    content: [{ type: "text", text: `Successfully patched ${package_name} to v${version} and opened PR: ${prData.html_url}` }]
                };

            } catch (error: any) {
                // Try to revert back to previous branch if something fails
                try {
                    await execFileAsync('git', ['checkout', '-']);
                } catch { }

                return {
                    content: [{ type: "text", text: `Error applying security patch: ${error.message}` }],
                    isError: true
                };
            }
        }
    );
}
