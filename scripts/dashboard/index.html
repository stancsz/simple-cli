<!DOCTYPE html>
<html>
<head>
  <title>Agent Health Dashboard</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    .chart-container { width: 100%; height: 300px; margin-bottom: 20px; border: 1px solid #ddd; padding: 10px; }
    h1 { color: #333; }
    h2 { margin-top: 30px; }
    select { padding: 5px; font-size: 16px; margin-bottom: 20px; }
    ul#alertsList { list-style-type: none; padding: 0; }
    ul#alertsList li { padding: 10px; border-bottom: 1px solid #eee; }
    ul#alertsList li:last-child { border-bottom: none; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Agent Health Dashboard</h1>
  <label for="timeframe">Timeframe:</label>
  <select id="timeframe" onchange="fetchData()">
    <option value="last_hour">Last Hour</option>
    <option value="last_day">Last Day</option>
    <option value="last_week">Last Week</option>
  </select>

  <div class="chart-container">
    <canvas id="latencyChart"></canvas>
  </div>
  <div class="chart-container">
    <canvas id="tokensChart"></canvas>
  </div>
  <div class="chart-container">
    <canvas id="errorsChart"></canvas>
  </div>

  <h2>Recent Alerts</h2>
  <ul id="alertsList">
      <li>Loading alerts...</li>
  </ul>

  <script>
    let latencyChartInstance = null;
    let tokensChartInstance = null;
    let errorsChartInstance = null;

    async function fetchData() {
      const timeframe = document.getElementById('timeframe').value;
      try {
          // Fetch Metrics
          const response = await fetch(`/api/metrics?timeframe=${timeframe}`);
          if (response.ok) {
              const data = await response.json();
              updateCharts(data);
          } else {
              console.error("Failed to fetch metrics");
          }

          // Fetch Alerts
          const alertsResponse = await fetch('/api/alerts');
          if (alertsResponse.ok) {
              const alertsData = await alertsResponse.json();
              updateAlerts(alertsData);
          } else {
              console.error("Failed to fetch alerts");
          }

      } catch (e) {
          console.error("Failed to fetch data", e);
      }
    }

    function updateAlerts(alerts) {
        const list = document.getElementById('alertsList');
        list.innerHTML = '';
        if (!alerts || alerts.length === 0) {
            list.innerHTML = '<li>No recent alerts</li>';
            return;
        }
        alerts.forEach(a => {
            const li = document.createElement('li');
            li.textContent = `${new Date(a.timestamp).toLocaleString()} - ${a.message}`;
            li.style.color = 'red';
            list.appendChild(li);
        });
    }

    function updateCharts(data) {
      // Process Data
      const latencyData = data.filter(m => m.metric === 'llm_latency').map(m => ({ x: m.timestamp, y: m.value }));
      const tokensData = data.filter(m => m.metric === 'llm_tokens_total').map(m => ({ x: m.timestamp, y: m.value }));
      const errorsData = data.filter(m => m.metric.includes('error')).map(m => ({ x: m.timestamp, y: m.value }));

      // Update Charts
      updateChart('latencyChart', 'LLM Latency (ms)', latencyData, 'line', (chart) => latencyChartInstance = chart, latencyChartInstance);
      updateChart('tokensChart', 'Total Tokens', tokensData, 'bar', (chart) => tokensChartInstance = chart, tokensChartInstance);
      updateChart('errorsChart', 'Errors', errorsData, 'bar', (chart) => errorsChartInstance = chart, errorsChartInstance);
    }

    function updateChart(canvasId, label, data, type, setInstance, instance) {
      const ctx = document.getElementById(canvasId).getContext('2d');
      const config = {
        type: type,
        data: {
          labels: data.map(d => new Date(d.x).toLocaleTimeString()),
          datasets: [{
            label: label,
            data: data.map(d => d.y),
            backgroundColor: 'rgba(54, 162, 235, 0.5)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
             x: { display: true },
             y: { beginAtZero: true }
          }
        }
      };

      if (instance) {
          instance.destroy();
      }

      const newChart = new Chart(ctx, config);
      setInstance(newChart);
    }

    // Refresh every minute
    fetchData();
    setInterval(fetchData, 60000);
  </script>
</body>
</html>
